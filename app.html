<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>UK Urban Planning Mobile App</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #header {
            background-color: #f0f0f0;
            padding: 10px;
            text-align: center;
        }

        #mapContainer {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }

        .dropdown {
            margin-bottom: 10px;
        }

        .dropbtn {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: none;
            background-color: #f1f1f1;
            cursor: pointer;
        }

        .dropdown-content {
            display: none;
            background-color: #f9f9f9;
            max-height: 200px;
            overflow-y: auto;
        }

        .dropdown-content button {
            width: 100%;
            padding: 12px 16px;
            border: none;
            background-color: white;
            cursor: pointer;
            text-align: left;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
        }

        #infoPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            max-height: 30vh;
            overflow-y: auto;
        }

        #infoPanel h3 {
            margin-top: 0;
        }

        #infoPanel ul {
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="header">
            <h2>UK Urban Planning</h2>
        </div>
        <div id="mapContainer">
            <div id="map"></div>
            <div id="controls">
                <div class="dropdown">
                    <button class="dropbtn" id="categoryDropBtn">Select Category</button>
                    <div id="categoryDropdown" class="dropdown-content"></div>
                </div>
                <div class="dropdown">
                    <button class="dropbtn" id="criteriaDropBtn">Select Criteria</button>
                    <div id="criteriaDropdown" class="dropdown-content"></div>
                </div>
                <div class="slider-container">
                    <label for="thresholdSlider">Threshold: <span id="thresholdValue">0</span></label>
                    <input type="range" id="thresholdSlider" min="0" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label for="rankSlider">Rank: <span id="rankValue">1</span></label>
                    <input type="range" id="rankSlider" min="1" max="1" value="1">
                </div>
            </div>
        </div>
        <div id="infoPanel"></div>
    </div>

    <script>
    let solutionCriteria = {};
    let challengeCategories = {};
    let criteriaRasters = {};
    let currentCategory = "Biodiversity and soils";
    let currentSolution = null;
    let currentThreshold = 0;
    let currentRank = 1;
    let selectedCell = null;

    async function fetchJSONData() {
        try {
            const [solutionCriteriaResponse, challengeCategoriesResponse] = await Promise.all([
                fetch('solutionCriteria.json'),
                fetch('challengeCategories.json')
            ]);

            solutionCriteria = await solutionCriteriaResponse.json();
            challengeCategories = await challengeCategoriesResponse.json();

            initializeApp();
        } catch (error) {
            console.error('Error loading JSON data:', error);
        }
    }

    function initializeApp() {
        generateCriteriaRasters();
        setupEventListeners();
        createDropdownOptions();
        updateMap(currentCategory);
    }

    function generateCriteriaRasters() {
        Object.values(solutionCriteria).flat().forEach((criterion, index) => {
            criteriaRasters[criterion] = generateBinaryRaster(100, 100, index);
        });
    }

    function generateBinaryRaster(width, height, seed) {
        const raster = [];
        const numShapes = 5 + Math.floor(Math.random() * 5);

        for (let y = 0; y < height; y++) {
            raster.push(new Array(width).fill(0));
        }

        for (let i = 0; i < numShapes; i++) {
            const centerX = Math.floor(Math.random() * width);
            const centerY = Math.floor(Math.random() * height);
            const maxRadius = Math.min(20, Math.min(width, height) / 5);
            const radius = 5 + Math.floor(Math.random() * maxRadius);

            for (let y = Math.max(0, centerY - radius); y < Math.min(height, centerY + radius); y++) {
                for (let x = Math.max(0, centerX - radius); x < Math.min(width, centerX + radius); x++) {
                    if (Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2) <= Math.pow(radius, 2)) {
                        raster[y][x] = 1;
                    }
                }
            }
        }

        return raster;
    }

    function setupEventListeners() {
        const thresholdSlider = document.getElementById('thresholdSlider');
        const rankSlider = document.getElementById('rankSlider');

        thresholdSlider.addEventListener('input', function() {
            currentThreshold = parseInt(this.value);
            document.getElementById('thresholdValue').textContent = currentThreshold;
            updateMap(currentCategory, currentSolution);
        });

        rankSlider.addEventListener('input', function() {
            currentRank = parseInt(this.value);
            document.getElementById('rankValue').textContent = currentRank;
            updateMap(currentCategory, currentSolution);
        });

        document.getElementById('categoryDropBtn').addEventListener('click', function() {
            toggleDropdown('categoryDropdown');
        });

        document.getElementById('criteriaDropBtn').addEventListener('click', function() {
            toggleDropdown('criteriaDropdown');
        });
    }

    function toggleDropdown(id) {
        document.getElementById(id).style.display = 
            document.getElementById(id).style.display === "block" ? "none" : "block";
    }

    function createDropdownOptions() {
        const categoryDropdown = document.getElementById('categoryDropdown');
        const criteriaDropdown = document.getElementById('criteriaDropdown');

        Object.keys(challengeCategories).forEach(category => {
            const button = document.createElement('button');
            button.textContent = category;
            button.onclick = function() {
                currentCategory = category;
                document.getElementById('categoryDropBtn').textContent = category;
                updateMap(category);
                toggleDropdown('categoryDropdown');
            };
            categoryDropdown.appendChild(button);
        });

        Object.keys(solutionCriteria).forEach(solution => {
            const button = document.createElement('button');
            button.textContent = solution;
            button.onclick = function() {
                currentSolution = solution;
                document.getElementById('criteriaDropBtn').textContent = solution;
                displayCriteriaRasters(solution);
                toggleDropdown('criteriaDropdown');
            };
            criteriaDropdown.appendChild(button);
        });
    }

    function updateMap(challengeCategory, solution) {
        const gridSize = 13;
        const suitabilityScores = calculateSuitabilityScores(gridSize, challengeCategory);

        const svg = d3.select("#map").html("").append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${gridSize} ${gridSize}`);

        const customColors = [
            "#4e79a7", "#f28e2c", "#e15759", "#76b7b2", "#59a14f",
            "#edc949", "#af7aa1", "#ff9da7", "#9c755f", "#bab0ab"
        ];

        const colorScale = d3.scaleOrdinal()
            .domain(Object.keys(solutionCriteria))
            .range(customColors);

        svg.selectAll("rect")
            .data(suitabilityScores.flat())
            .enter().append("rect")
            .attr("x", (d, i) => i % gridSize)
            .attr("y", (d, i) => Math.floor(i / gridSize))
            .attr("width", 1)
            .attr("height", 1)
            .attr("fill", d => {
                if (solution) {
                    return d[solution] >= currentThreshold ? d3.interpolateBlues(d[solution] / 100) : "white";
                } else {
                    const sortedSolutions = Object.entries(d).sort((a, b) => b[1] - a[1]);
                    const rankedSolution = sortedSolutions[currentRank - 1];
                    return rankedSolution && rankedSolution[1] >= currentThreshold ? colorScale(rankedSolution[0]) : "white";
                }
            })
            .attr("opacity", 0.7)
            .on("click", (event, d) => {
                if (selectedCell) {
                    selectedCell.attr("stroke", null);
                }
                selectedCell = d3.select(event.currentTarget);
                selectedCell.attr("stroke", "black").attr("stroke-width", 0.1);
                showCellScores(d);
            });

        updateTotals(suitabilityScores.flat());
        document.getElementById('rankSlider').max = Object.keys(solutionCriteria).length;
    }

    function calculateSuitabilityScores(gridSize, challengeCategory) {
        const grid = [];
        for (let y = 0; y < gridSize; y++) {
            const row = [];
            for (let x = 0; x < gridSize; x++) {
                const cellScores = {};
                for (const [solution, criteria] of Object.entries(solutionCriteria)) {
                    const area = calculateOverlapArea(x, y, criteria, gridSize);
                    const weight = challengeCategories[challengeCategory][solution];
                    cellScores[solution] = area * weight * 100;
                }
                row.push(cellScores);
            }
            grid.push(row);
        }
        return grid;
    }

    function calculateOverlapArea(x, y, criteria, gridSize) {
        let totalValue = 0;
        criteria.forEach(criterion => {
            const raster = criteriaRasters[criterion];
            const rasterX = Math.floor(x / gridSize * raster.length);
            const rasterY = Math.floor(y / gridSize * raster[0].length);
            totalValue += raster[rasterY][rasterX];
        });
        return totalValue / criteria.length;
    }

    function showCellScores(d) {
        const infoPanel = document.getElementById('infoPanel');
        let html = "<h3>Selected Cell Impact Scores:</h3><ul>";
        
        const sortedSolutions = Object.entries(d)
            .filter(([_, score]) => score >= currentThreshold)
            .sort((a, b) => b[1] - a[1]);

        sortedSolutions.forEach(([solution, score], index) => {
            html += `<li>${solution}: ${score.toFixed(2)} (Rank: ${index + 1})</li>`;
        });
        html += "</ul>";
        infoPanel.innerHTML = html;
    }

    function updateTotals(data) {
        const totals = {};
        data.forEach(cell => {
            const sortedSolutions = Object.entries(cell)
                .filter(([_, score]) => score >= currentThreshold)
                .sort((a, b) => b[1] - a[1]);
            
            if (sortedSolutions.length >= currentRank) {
                const [solution, score] = sortedSolutions[currentRank - 1];
                totals[solution] = (totals[solution] || 0) + score;
            }
        });

        const sortedTotals = Object.entries(totals).sort((a, b) => b[1] - a[1]);

        let html = `<h3>Total Impact Scores (Rank ${currentRank}):</h3><ul>`;
        for (const [solution, total] of sortedTotals) {
            html += `<li>${solution}: ${total.toFixed(2)}</li>`;
        }
        html += "</ul>";
        
        const existingContent = document.getElementById('infoPanel').innerHTML;
        document.getElementById('infoPanel').innerHTML = existingContent + html;
    }

    function displayCriteriaRasters(solution) {
        const criteria = solutionCriteria[solution];
        const raster1 = criteriaRasters[criteria[0]];
        const raster2 = criteriaRasters[criteria[1]];

        const svg = d3.select("#map").html("").append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${raster1.length} ${raster1.length}`);

        const allCriteria = [...new Set(Object.values(solutionCriteria).flat())];
        const criteriaColorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(allCriteria);

        svg.selectAll(".raster1")
            .data(raster1.flat())
            .enter().append("rect")
            .attr("class", "raster1")
            .attr("x", (d, i) => i % raster1.length)
            .attr("y", (d, i) => Math.floor(i / raster1.length))
            .attr("width", 0.5)
            .attr("height", 1)
            .attr("fill", d => d ? criteriaColorScale(criteria[0]) : "white")
            .attr("opacity", d => d ? 1 : 0.1);

            svg.selectAll(".raster2")
            .data(raster2.flat())
            .enter().append("rect")
            .attr("class", "raster2")
            .attr("x", (d, i) => (i % raster2.length) + 0.5)
            .attr("y", (d, i) => Math.floor(i / raster2.length))
            .attr("width", 0.5)
            .attr("height", 1)
            .attr("fill", d => d ? criteriaColorScale(criteria[1]) : "white")
            .attr("opacity", d => d ? 1 : 0.1);

        const areas = calculateCriteriaAreas(raster1, raster2);
        updateCriteriaInfo(solution, criteria, areas, criteriaColorScale);

        document.getElementById('controls').style.display = 'none';
    }

    function calculateCriteriaAreas(raster1, raster2) {
        let area1 = 0, area2 = 0, overlapArea = 0;
        const totalCells = raster1.length * raster1[0].length;

        for (let y = 0; y < raster1.length; y++) {
            for (let x = 0; x < raster1[0].length; x++) {
                if (raster1[y][x]) area1++;
                if (raster2[y][x]) area2++;
                if (raster1[y][x] && raster2[y][x]) overlapArea++;
            }
        }

        return {
            criteria1: (area1 / totalCells) * 100,
            criteria2: (area2 / totalCells) * 100,
            overlap: (overlapArea / totalCells) * 100
        };
    }

    function updateCriteriaInfo(solution, criteria, areas, colorScale) {
        const infoPanel = document.getElementById('infoPanel');
        infoPanel.innerHTML = `
            <h3>${solution} Criteria Areas</h3>
            <ul>
                <li>${criteria[0]}: ${areas.criteria1.toFixed(2)}%</li>
                <li>${criteria[1]}: ${areas.criteria2.toFixed(2)}%</li>
                <li>Overlap: ${areas.overlap.toFixed(2)}%</li>
            </ul>
        `;
    }

    fetchJSONData();
    </script>
</body>
</html>