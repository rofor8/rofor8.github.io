<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UK Urban Planning D3 Map Application</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            margin: 0;
            padding: 0;
        }
        #sidebar {
            width: 250px;
            background-color: #f0f0f0;
            padding: 20px;
            height: 100vh;
            overflow-y: auto;
        }
        #mapContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #map {
            flex: 1;
        }
        #legend {
            padding: 10px;
        }
        .category-button, .solution-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 5px;
            text-align: left;
            background-color: #e0e0e0;
            border: none;
            cursor: pointer;
        }
        .category-button.active, .solution-button.active {
            background-color: #4CAF50;
            color: white;
        }
        #cellInfo {
            position: absolute;
            background: white;
            border: 1px solid black;
            padding: 10px;
            display: none;
        }
        #solutionDropdown {
            width: 100%;
            padding: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <p class="section-explanation">
            View how different urban planning solutions suit specific environmental and urban criteria. Each solution is evaluated using two key factors.
        </p>
        <div id="criteriaButtons"></div>
        <p class="section-explanation">
            Select urban challenges to see how various solutions impact them. The map will show the most suitable solutions for each challenge.
        </p>
        <div id="categoryButtons"></div>
        <p class="section-explanation">
            After selecting a challenge, choose a specific solution to see its suitability across the entire map.
        </p>
        <div id="solutionButtons"></div>
    </div>
    
    <div id="mapContainer">
        <div class="instruction">
            The map below visualizes the analysis results. Click on cells for detailed information.
        </div>
        <div id="map"></div>
        <div id="legend"></div>
    </div>
    
    <div id="cellInfo"></div>

    <script>
    // JSON data
    const solutionCriteria = {
        "sustainable drainage systems": ["soil permeability", "flood risk"],
        "green and blue roofs": ["building density", "rainfall"],
        "green walls": ["building height", "air quality"],
        "rain gardens": ["soil type", "urban runoff"],
        "swales": ["topography", "water flow"],
        "features for species": ["biodiversity index", "habitat connectivity"],
        "trees in hard landscapes": ["urban heat island", "air quality"],
        "street furniture and utility structures": ["population density", "pedestrian flow"],
        "traffic-free routes": ["current road network", "air quality"],
        "allotments": ["soil quality", "population density"],
        "orchards": ["soil type", "sunlight exposure"],
        "private domestic gardens": ["housing density", "socioeconomic factors"],
        "green spaces": ["land availability", "accessibility"]
    };

    const challengeCategories = {
        "Biodiversity and soils": {
            "sustainable drainage systems": 0.7,
            "green and blue roofs": 0.5,
            "green walls": 0.6,
            "rain gardens": 0.8,
            "swales": 0.7,
            "features for species": 0.9,
            "trees in hard landscapes": 0.8,
            "street furniture and utility structures": 0.3,
            "traffic-free routes": 0.4,
            "allotments": 0.7,
            "orchards": 0.8,
            "private domestic gardens": 0.6,
            "green spaces": 0.9
        },
        "Landscape and geodiversity": {
            "sustainable drainage systems": 0.6,
            "green and blue roofs": 0.7,
            "green walls": 0.8,
            "rain gardens": 0.7,
            "swales": 0.8,
            "features for species": 0.7,
            "trees in hard landscapes": 0.9,
            "street furniture and utility structures": 0.5,
            "traffic-free routes": 0.6,
            "allotments": 0.5,
            "orchards": 0.7,
            "private domestic gardens": 0.6,
            "green spaces": 0.9
        },
        "Water management": {
            "sustainable drainage systems": 0.9,
            "green and blue roofs": 0.8,
            "green walls": 0.4,
            "rain gardens": 0.9,
            "swales": 0.9,
            "features for species": 0.3,
            "trees in hard landscapes": 0.6,
            "street furniture and utility structures": 0.2,
            "traffic-free routes": 0.3,
            "allotments": 0.4,
            "orchards": 0.5,
            "private domestic gardens": 0.6,
            "green spaces": 0.7
        },
        "Carbon and energy": {
            "sustainable drainage systems": 0.4,
            "green and blue roofs": 0.7,
            "green walls": 0.8,
            "rain gardens": 0.3,
            "swales": 0.3,
            "features for species": 0.5,
            "trees in hard landscapes": 0.9,
            "street furniture and utility structures": 0.2,
            "traffic-free routes": 0.6,
            "allotments": 0.4,
            "orchards": 0.6,
            "private domestic gardens": 0.5,
            "green spaces": 0.8
        },
        "Urban cooling": {
            "sustainable drainage systems": 0.6,
            "green and blue roofs": 0.9,
            "green walls": 0.9,
            "rain gardens": 0.7,
            "swales": 0.6,
            "features for species": 0.4,
            "trees in hard landscapes": 0.9,
            "street furniture and utility structures": 0.3,
            "traffic-free routes": 0.5,
            "allotments": 0.5,
            "orchards": 0.7,
            "private domestic gardens": 0.7,
            "green spaces": 0.9
        },
        "Sense of place": {
            "sustainable drainage systems": 0.5,
            "green and blue roofs": 0.6,
            "green walls": 0.8,
            "rain gardens": 0.7,
            "swales": 0.6,
            "features for species": 0.8,
            "trees in hard landscapes": 0.9,
            "street furniture and utility structures": 0.7,
            "traffic-free routes": 0.8,
            "allotments": 0.8,
            "orchards": 0.9,
            "private domestic gardens": 0.8,
            "green spaces": 0.9
        },
        "Education": {
            "sustainable drainage systems": 0.6,
            "green and blue roofs": 0.5,
            "green walls": 0.5,
            "rain gardens": 0.7,
            "swales": 0.6,
            "features for species": 0.9,
            "trees in hard landscapes": 0.7,
            "street furniture and utility structures": 0.4,
            "traffic-free routes": 0.5,
            "allotments": 0.9,
            "orchards": 0.8,
            "private domestic gardens": 0.6,
            "green spaces": 0.9
        },
        "Food production": {
            "sustainable drainage systems": 0.3,
            "green and blue roofs": 0.5,
            "green walls": 0.4,
            "rain gardens": 0.3,
            "swales": 0.2,
            "features for species": 0.4,
            "trees in hard landscapes": 0.5,
            "street furniture and utility structures": 0.1,
            "traffic-free routes": 0.2,
            "allotments": 0.9,
            "orchards": 0.9,
            "private domestic gardens": 0.8,
            "green spaces": 0.7
        },
        "Access to nature": {
            "sustainable drainage systems": 0.5,
            "green and blue roofs": 0.6,
            "green walls": 0.7,
            "rain gardens": 0.7,
            "swales": 0.6,
            "features for species": 0.9,
            "trees in hard landscapes": 0.8,
            "street furniture and utility structures": 0.4,
            "traffic-free routes": 0.7,
            "allotments": 0.8,
            "orchards": 0.8,
            "private domestic gardens": 0.7,
            "green spaces": 0.9
        },
        "Active lifestyles": {
            "sustainable drainage systems": 0.3,
            "green and blue roofs": 0.4,
            "green walls": 0.3,
            "rain gardens": 0.4,
            "swales": 0.4,
            "features for species": 0.5,
            "trees in hard landscapes": 0.6,
            "street furniture and utility structures": 0.5,
            "traffic-free routes": 0.9,
            "allotments": 0.7,
            "orchards": 0.6,
            "private domestic gardens": 0.6,
            "green spaces": 0.9
        },
        "Air": {
            "sustainable drainage systems": 0.4,
            "green and blue roofs": 0.7,
            "green walls": 0.9,
            "rain gardens": 0.5,
            "swales": 0.4,
            "features for species": 0.6,
            "trees in hard landscapes": 0.9,
            "street furniture and utility structures": 0.2,
            "traffic-free routes": 0.7,
            "allotments": 0.5,
            "orchards": 0.7,
            "private domestic gardens": 0.6,
            "green spaces": 0.8
        },
        "Noise": {
            "sustainable drainage systems": 0.3,
            "green and blue roofs": 0.6,
            "green walls": 0.8,
            "rain gardens": 0.4,
            "swales": 0.4,
            "features for species": 0.5,
            "trees in hard landscapes": 0.8,
            "street furniture and utility structures": 0.6,
            "traffic-free routes": 0.7,
            "allotments": 0.4,
            "orchards": 0.6,
            "private domestic gardens": 0.5,
            "green spaces": 0.7
        }
    };

    function generateBinaryRaster(width, height, seed) {
    const raster = [];
    const numShapes = 5 + Math.floor(Math.random() * 5); // 5 to 9 shapes

    // Initialize raster with zeros
    for (let y = 0; y < height; y++) {
        raster.push(new Array(width).fill(0));
    }

    // Generate random shapes
    for (let i = 0; i < numShapes; i++) {
        const centerX = Math.floor(Math.random() * width);
        const centerY = Math.floor(Math.random() * height);
        const maxRadius = Math.min(20, Math.min(width, height) / 5);
        const radius = 5 + Math.floor(Math.random() * maxRadius);

        for (let y = Math.max(0, centerY - radius); y < Math.min(height, centerY + radius); y++) {
            for (let x = Math.max(0, centerX - radius); x < Math.min(width, centerX + radius); x++) {
                if (Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2) <= Math.pow(radius, 2)) {
                    raster[y][x] = 1;
                }
            }
        }
    }

    return raster;
}

// Update the criteriaRasters object
const criteriaRasters = {
    "soil permeability": generateBinaryRaster(100, 100, 0),
    "flood risk": generateBinaryRaster(100, 100, 1),
    "building density": generateBinaryRaster(100, 100, 2),
    "rainfall": generateBinaryRaster(100, 100, 3),
    "building height": generateBinaryRaster(100, 100, 4),
    "air quality": generateBinaryRaster(100, 100, 5),
    "soil type": generateBinaryRaster(100, 100, 6),
    "urban runoff": generateBinaryRaster(100, 100, 7),
    "topography": generateBinaryRaster(100, 100, 8),
    "water flow": generateBinaryRaster(100, 100, 9),
    "biodiversity index": generateBinaryRaster(100, 100, 10),
    "habitat connectivity": generateBinaryRaster(100, 100, 11),
    "urban heat island": generateBinaryRaster(100, 100, 12),
    "population density": generateBinaryRaster(100, 100, 13),
    "pedestrian flow": generateBinaryRaster(100, 100, 14),
    "current road network": generateBinaryRaster(100, 100, 15),
    "soil quality": generateBinaryRaster(100, 100, 16),
    "sunlight exposure": generateBinaryRaster(100, 100, 17),
    "housing density": generateBinaryRaster(100, 100, 18),
    "socioeconomic factors": generateBinaryRaster(100, 100, 19),
    "land availability": generateBinaryRaster(100, 100, 20),
    "accessibility": generateBinaryRaster(100, 100, 21)
};

    // Calculate suitability scores
    function calculateSuitabilityScores(gridSize, challengeCategory) {
        const grid = [];
        for (let y = 0; y < gridSize; y++) {
            const row = [];
            for (let x = 0; x < gridSize; x++) {
                const cellScores = {};
                for (const [solution, criteria] of Object.entries(solutionCriteria)) {
                    const area = calculateOverlapArea(x, y, criteria, gridSize);
                    const weight = challengeCategories[challengeCategory][solution];
                    cellScores[solution] = area * weight;
                }
                row.push(cellScores);
            }
            grid.push(row);
        }
        return grid;
    }

    function calculateOverlapArea(x, y, criteria, gridSize) {
        // Simplified area calculation based on criteria rasters
        let totalValue = 0;
        criteria.forEach(criterion => {
            const raster = criteriaRasters[criterion];
            const rasterX = Math.floor(x / gridSize * raster.length);
            const rasterY = Math.floor(y / gridSize * raster[0].length);
            totalValue += raster[rasterY][rasterX];
        });
        return totalValue / (criteria.length * 9); // Normalize to 0-1 range
    }

    // Set up SVG
    const svg = d3.select("#map").append("svg")
        .attr("width", "100%")
        .attr("height", "100%");

    // Define color scale for solutions
    const customColors = [
        "#4e79a7", "#f28e2c", "#e15759", "#76b7b2", "#59a14f",
        "#edc949", "#af7aa1", "#ff9da7", "#9c755f", "#bab0ab",
        "#4e79a7", "#f28e2c", "#e15759"
    ];

    const colorScale = d3.scaleOrdinal()
        .domain(Object.keys(solutionCriteria))
        .range(customColors);

    let currentCategory = null;
    let currentSolution = null;

    function updateMap(challengeCategory, solution) {
        const gridSize = 13; // Fixed grid size
        const suitabilityScores = calculateSuitabilityScores(gridSize, challengeCategory);

        // Clear previous grid
        svg.selectAll("rect").remove();

        // Draw grid cells
        const svgWidth = parseInt(svg.style("width"));
        const svgHeight = parseInt(svg.style("height"));
        const cellSize = Math.min(svgWidth, svgHeight) / gridSize;

        svg.selectAll("rect")
            .data(suitabilityScores.flat())
            .enter().append("rect")
            .attr("x", (d, i) => (i % gridSize) * cellSize)
            .attr("y", (d, i) => Math.floor(i / gridSize) * cellSize)
            .attr("width", cellSize)
            .attr("height", cellSize)
            .attr("fill", d => {
                if (solution) {
                    return d3.interpolateBlues(d[solution]); // Use color scale for specific solution
                } else {
                    const maxSolution = Object.entries(d).reduce((a, b) => a[1] > b[1] ? a : b)[0];
                    return colorScale(maxSolution);
                }
            })
            .attr("opacity", 0.7)
            .on("click", showCellScores)
            .on("mouseover", highlightCell)
            .on("mouseout", unhighlightCell);

        // Update legend
        updateLegend(challengeCategory, solution);
    }

    function showCellScores(event, d) {
        const cellInfo = d3.select("#cellInfo");
        cellInfo.style("display", "block")
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY + 10) + "px");

        let html = "<h3>Solution Impact Scores:</h3><ul>";
        for (const [solution, score] of Object.entries(d)) {
            html += `<li>${solution}: ${score.toFixed(3)}</li>`;
        }
        html += "</ul>";
        cellInfo.html(html);
    }

    function highlightCell(event, d) {
        d3.select(event.currentTarget).attr("opacity", 1);
    }

    function unhighlightCell(event, d) {
        d3.select(event.currentTarget).attr("opacity", 0.7);
    }

    // Set up controls
    const categoryButtons = d3.select("#categoryButtons");
    categoryButtons.selectAll("button")
        .data(Object.keys(challengeCategories))
        .enter().append("button")
        .attr("class", "category-button")
        .text(d => d)
        .on("click", function(event, d) {
            d3.selectAll(".category-button").classed("active", false);
            d3.select(this).classed("active", true);
            currentCategory = d;
            currentSolution = null;
            d3.selectAll(".solution-button").classed("active", false);
            updateMap(d);
        });

        const solutionButtons = d3.select("#solutionButtons");
        solutionButtons.selectAll("button")
            .data(Object.keys(solutionCriteria))
            .enter().append("button")
            .attr("class", "solution-button")
            .text(d => d)
            .on("click", function(event, d) {
                if (currentCategory) {
                    d3.selectAll(".solution-button").classed("active", false);
                    if (currentSolution === d) {
                        currentSolution = null;
                        d3.select(this).classed("active", false);
                    } else {
                        currentSolution = d;
                        d3.select(this).classed("active", true);
                    }
                    updateMap(currentCategory, currentSolution);
                }
            });

// Set up criteria buttons
const criteriaButtons = d3.select("#criteriaButtons");
criteriaButtons.selectAll("button")
    .data(Object.keys(solutionCriteria))
    .enter().append("button")
    .attr("class", "solution-button")
    .text(d => d)
    .on("click", function(event, d) {
        const isActive = d3.select(this).classed("active");
        d3.selectAll(".solution-button").classed("active", false);
        if (!isActive) {
            d3.select(this).classed("active", true);
            displayCriteriaRasters(d);
        } else {
            // If deactivating, revert to the current category/solution view
            updateMap(currentCategory, currentSolution);
        }
    });

// Update the displayCriteriaRasters function to handle button toggling
function displayCriteriaRasters(solution) {
    const criteria = solutionCriteria[solution];
    const raster1 = criteriaRasters[criteria[0]];
    const raster2 = criteriaRasters[criteria[1]];

    // Clear previous grid
    svg.selectAll("rect").remove();

    const svgWidth = parseInt(svg.style("width"));
    const svgHeight = parseInt(svg.style("height"));
    const cellSize = Math.min(svgWidth, svgHeight) / raster1.length;

    // Draw first criteria raster
    svg.selectAll(".raster1")
        .data(raster1.flat())
        .enter().append("rect")
        .attr("class", "raster1")
        .attr("x", (d, i) => (i % raster1.length) * cellSize)
        .attr("y", (d, i) => Math.floor(i / raster1.length) * cellSize)
        .attr("width", cellSize / 2)
        .attr("height", cellSize)
        .attr("fill", d => d3.interpolateBlues(d / 10));

    // Draw second criteria raster
    svg.selectAll(".raster2")
        .data(raster2.flat())
        .enter().append("rect")
        .attr("class", "raster2")
        .attr("x", (d, i) => (i % raster2.length) * cellSize + cellSize / 2)
        .attr("y", (d, i) => Math.floor(i / raster2.length) * cellSize)
        .attr("width", cellSize / 2)
        .attr("height", cellSize)
        .attr("fill", d => d3.interpolateGreens(d / 10));

    // Update legend
    updateLegend(criteria);
}

    function displayCriteriaRasters(solution) {
        const criteria = solutionCriteria[solution];
        const raster1 = criteriaRasters[criteria[0]];
        const raster2 = criteriaRasters[criteria[1]];

        // Clear previous grid
        svg.selectAll("rect").remove();

        const svgWidth = parseInt(svg.style("width"));
        const svgHeight = parseInt(svg.style("height"));
        const cellSize = Math.min(svgWidth, svgHeight) / raster1.length;

        // Draw first criteria raster
        svg.selectAll(".raster1")
            .data(raster1.flat())
            .enter().append("rect")
            .attr("class", "raster1")
            .attr("x", (d, i) => (i % raster1.length) * cellSize)
            .attr("y", (d, i) => Math.floor(i / raster1.length) * cellSize)
            .attr("width", cellSize / 2)
            .attr("height", cellSize)
            .attr("fill", d => d ? "blue" : "white");

        // Draw second criteria raster
        svg.selectAll(".raster2")
            .data(raster2.flat())
            .enter().append("rect")
            .attr("class", "raster2")
            .attr("x", (d, i) => (i % raster2.length) * cellSize + cellSize / 2)
            .attr("y", (d, i) => Math.floor(i / raster2.length) * cellSize)
            .attr("width", cellSize / 2)
            .attr("height", cellSize)
            .attr("fill", d => d ? "green" : "white");

        // Update legend
        updateLegend(criteria);
    }

    function updateLegend(category, solution) {
    // Clear previous legend
    d3.select("#legend").selectAll("*").remove();

    const legendSvg = d3.select("#legend").append("svg")
        .attr("width", "100%")
        .attr("height", "60px");

    if (solution) {
        // Show legend for specific solution
        const colorScale = d3.scaleSequential(d3.interpolateBlues).domain([0, 1]);

        legendSvg.append("text")
            .attr("x", 0)
            .attr("y", 15)
            .text(`${solution} suitability`);

        const legend = legendSvg.append("g")
            .attr("transform", "translate(0, 20)");

        const gradientData = d3.range(0, 1, 0.01);
        legend.selectAll("rect")
            .data(gradientData)
            .enter().append("rect")
            .attr("x", (d, i) => i * 2)
            .attr("y", 0)
            .attr("width", 2)
            .attr("height", 20)
            .attr("fill", d => colorScale(d));

        // Add labels
        legend.append("text")
            .attr("x", 0)
            .attr("y", 35)
            .text("Low");

        legend.append("text")
            .attr("x", 200 - 30)
            .attr("y", 35)
            .text("High");
    } else {
        // Show legend for all solutions in the category
        const solutions = Object.keys(challengeCategories[category]);
        const legend = legendSvg.selectAll(".legend")
            .data(solutions)
            .enter().append("g")
            .attr("class", "legend")
            .attr("transform", (d, i) => `translate(0, ${i * 20})`);

        legend.append("rect")
            .attr("x", 0)
            .attr("width", 18)
            .attr("height", 18)
            .style("fill", d => colorScale(d));

        legend.append("text")
            .attr("x", 24)
            .attr("y", 9)
            .attr("dy", ".35em")
            .style("text-anchor", "start")
            .text(d => d);
    }
}

    // Create initial legend
    const legendSvg = d3.select("#legend").append("svg")
        .attr("width", "100%")
        .attr("height", Object.keys(solutionCriteria).length * 20);

    const legend = legendSvg.selectAll(".legend")
        .data(Object.keys(solutionCriteria))
        .enter().append("g")
        .attr("class", "legend")
        .attr("transform", (d, i) => `translate(0, ${i * 20})`);

    legend.append("rect")
        .attr("x", 0)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", d => colorScale(d));

    legend.append("text")
        .attr("x", 24)
        .attr("y", 9)
        .attr("dy", ".35em")
        .style("text-anchor", "start")
        .text(d => d);

    // Initial map render
    updateMap(Object.keys(challengeCategories)[0]);
    </script>
</body>
</html>